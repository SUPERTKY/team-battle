<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TURI â€“ ãƒãƒ«ãƒã‚¿ãƒƒãƒ—ï¼†é€ƒèµ°ï¼†ã‚·ãƒ¥ãƒƒæ¶ˆãˆ</title>
<style>
  :root{
    --stage-w: min(1280px, 94vw);
    --ratio: 16/9;
    --fish-max: 6;
  }
  *{ box-sizing:border-box }
  html,body{ margin:0; height:100%; background:#05121a; color:#eaf7ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;}
  .wrap{ min-height:100%; display:grid; place-items:center; padding:16px; gap:12px; }

  .stage{
    position:relative;
    width: var(--stage-w);
    aspect-ratio: var(--ratio);
    overflow:hidden;
    border-radius:18px;
    background:#000;
    box-shadow:0 18px 48px rgba(0,0,0,.45);
  }

  /* èƒŒæ™¯å±¤ */
  .layer{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; pointer-events:none; }
  #sand{ z-index:1; }
  #waterBase{ z-index:2; opacity:.8; }
  .tint{ z-index:3; mix-blend-mode:multiply; background:rgba(25,181,193,.22); }
  .caustics{ z-index:4; opacity:.25; mix-blend-mode:screen; background:#000; filter:url(#causticsFilter); }

  /* é­šã¯æœ€å‰é¢ï¼ˆã‚¿ãƒƒãƒ—å¯ï¼‰ */
  #fishLayer{ position:absolute; inset:0; z-index:10; pointer-events:none; }
  .fish{
    position:absolute;
    transform-origin:center center;
    opacity:.96;
    will-change: transform, top, left;
    image-rendering:auto;
    pointer-events:auto; /* â† ã‚¿ãƒƒãƒ—å¯èƒ½ */
    user-select:none;
  }

  /* 1) ã‚¿ãƒƒãƒ—æ™‚ã®å°æºã‚Œï¼ˆè‡ªç„¶ãªãƒ“ã‚¯ã¤ãï¼‰ */
  .shake{
    animation: shake .22s ease-out;
  }
  @keyframes shake{
    0%{   transform: var(--rot0) translate(0, 0)   }
    35%{  transform: var(--rot0) translate(3px,-2px) }
    70%{  transform: var(--rot0) translate(-2px,2px) }
    100%{ transform: var(--rot0) translate(0,0) }
  }

  /* 2) ã‚·ãƒ¥ãƒƒã¨è‡ªç„¶ã«æ¶ˆãˆã‚‹ï¼ˆç¸®å°ï¼‹ãƒ•ã‚§ãƒ¼ãƒ‰ï¼‹è»½ã„ã¼ã‹ã—ï¼‰ */
  .vanish{
    animation: vanish .28s ease forwards;
  }
  @keyframes vanish{
    0%{   opacity:1;   filter: blur(0px);   transform: var(--rot0) scale(1) }
    100%{ opacity:0;   filter: blur(2px);   transform: var(--rot0) scale(0.75) }
  }

  /* ã‚¯ãƒªãƒƒã‚¯ã®æ°´ã—ã¶ãï¼ˆæ¼”å‡ºï¼‰ */
  .splash{
    position:absolute; width:8px; height:8px; border-radius:50%;
    left:0; top:0; transform: translate(-50%,-50%);
    background: rgba(255,255,255,.9); mix-blend-mode:screen;
    filter: blur(0.5px);
    pointer-events:none; z-index:11;
    animation: ripple .5s ease-out forwards;
  }
  @keyframes ripple{ to{ width:120px; height:120px; opacity:0; } }

  .hud{
    width: var(--stage-w);
    max-width: 100%;
    display:flex; justify-content:space-between; align-items:center;
    gap:10px;
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px; padding:10px 12px;
    font-weight:700;
  }
  .hud .muted{ opacity:.85; font-weight:600; }
</style>
</head>
<body>
  <main class="wrap">
    <section class="stage" id="stage" aria-label="é‡£ã‚Šã‚¹ãƒ†ãƒ¼ã‚¸">
      <img id="sand" class="layer" src="assets/sand.png" alt="ç ‚">
      <img id="waterBase" class="layer" src="assets/water_background_80percent.png" alt="æ°´">
      <div class="layer tint"></div>
      <div class="layer caustics"></div>
      <div id="fishLayer" aria-label="é­šãƒ¬ã‚¤ãƒ¤ãƒ¼"></div>
    </section>

    <div class="hud">
      <div>ğŸ¯ ã‚¹ã‚³ã‚¢ï¼š<span id="score">0</span></div>
      <div class="muted">é­šã‚’ã‚¿ãƒƒãƒ—ï¼ˆå¤§ãã„ã»ã©ã‚¿ãƒƒãƒ—å›æ•°â†‘ï¼†é€ƒã’è¶³â†‘ï¼†æ¶ˆãˆã‚‹ç¢ºç‡â†‘ï¼‰</div>
    </div>
  </main>

  <!-- æŸ”ã‚‰ã‹ã„ã‚«ãƒ¼ã‚¹ãƒ†ã‚£ã‚¯ã‚¹ -->
  <svg width="0" height="0" style="position:absolute">
    <filter id="causticsFilter">
      <feTurbulence type="fractalNoise" baseFrequency="0.005 0.02"
        numOctaves="2" seed="5" result="noise">
        <animateTransform attributeName="patternTransform"
          type="translate" from="0 0" to="200 0"
          dur="30s" repeatCount="indefinite"/>
      </feTurbulence>
      <feColorMatrix type="matrix" values="
        1 0 0 0 0
        0 1 0 0 0
        0 0 1 0 0
        0 0 0 6 -3" result="contrast"/>
      <feGaussianBlur stdDeviation="1.2"/>
    </filter>
  </svg>

<script>
/* ================= èª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ ================= */
const CONFIG = {
  FISH_MIN_SIZE: 110,     // pxï¼ˆæœ€å°ï¼‰
  FISH_MAX_SIZE: 220,     // pxï¼ˆæœ€å¤§ï¼‰
  FISH_MAX_COUNT: 6,      // åŒæ™‚æ•°

  BASE_SPEED: 110,        // é€šå¸¸é€Ÿåº¦ï¼ˆpx/sï¼‰â€»ã‚µã‚¤ã‚ºã§è£œæ­£
  TURN_RATE: 160,         // æ—‹å›ï¼ˆåº¦/ç§’ï¼‰
  EDGE_MARGIN: 56,        // ç«¯ã®å®‰å…¨åŸŸ
  RETARGET_SEC: [2.6, 5.2],
  GOAL_RADIUS: 18,
  NUDGE_INWARD: 14,

  // ã‚¿ãƒƒãƒ—é–¢é€£
  TAP_COOLDOWN_MS: 90,    // é€£æ‰“ã«ã‚ˆã‚‹å¤šé‡åˆ¤å®šã®æŠ‘åˆ¶
  TAP_IFRAME_MS: 120,     // åŒä¸€é­šã¸ã®é€£ç¶šã‚¿ãƒƒãƒ—ç„¡åŠ¹æ™‚é–“ï¼ˆèª¤å¤šé‡é˜²æ­¢ï¼‰

  // é€ƒèµ°ï¼ˆãƒ€ãƒƒã‚·ãƒ¥ï¼‰
  DASH_BASE: 260,         // ãƒ€ãƒƒã‚·ãƒ¥åŸºç¤é€Ÿåº¦ï¼ˆã‚µã‚¤ã‚ºã§æ›´ã«ä¸Šä¹—ã›ï¼‰
  DASH_TIME: 420,         // ãƒ€ãƒƒã‚·ãƒ¥ç¶™ç¶š(ms)

  // æ¶ˆãˆã‚‹ç¢ºç‡ï¼ˆåˆå›ã‚¿ãƒƒãƒ—ä»¥é™ï¼‰â€¦ã‚µã‚¤ã‚ºã§ä¸Šä¹—ã›
  VANISH_BASE: 0.12,
  VANISH_BY_SIZE: 0.20,   // ï¼ˆå¹…ãŒæœ€å°â†’æœ€å¤§ã§ï¼‰+0ã€œã“ã®å€¤ã‚’åŠ ç®—

  // ã‚¹ã‚³ã‚¢
  SCORE_PER_CATCH: 10
};
/* ================================================== */

const stage = document.getElementById('stage');
const fishLayer = document.getElementById('fishLayer');
const scoreEl = document.getElementById('score');
const fishImgSrc = 'assets/fish.png';

const FISHES = []; // {el,x,y,angle,width,speed,target,nextRetarget,seed,alive,hp,lastTapAt,dashUntil,vanishable}
let lastT = performance.now();
let lastTapAt = 0;
let score = 0;

/* utils */
const DEG2RAD = Math.PI/180;
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(a,b)=>Math.random()*(b-a)+a;

function insideBox(w,h){ return {
  x: rand(CONFIG.EDGE_MARGIN, w - CONFIG.EDGE_MARGIN),
  y: rand(CONFIG.EDGE_MARGIN, h - CONFIG.EDGE_MARGIN)
};}
function stepAngle(cur, target, maxStep){
  let diff = ((target - cur + 540) % 360) - 180;
  return cur + clamp(diff, -maxStep, maxStep);
}
function makeSplash(x,y){
  const sp = document.createElement('div');
  sp.className = 'splash';
  sp.style.left = x + 'px';
  sp.style.top  = y + 'px';
  stage.appendChild(sp);
  sp.addEventListener('animationend', ()=> sp.remove());
}
function addScore(v){ score = Math.max(0, score + v); scoreEl.textContent = score; }

/* ã‚µã‚¤ã‚ºâ†’é›£æ˜“åº¦ãƒãƒƒãƒ— */
function tapsNeededBySize(width){
  // æœ€å°â†’æœ€å¤§ã§ 2â†’4 å›ï¼ˆå¥½ã¿ã«åˆã‚ã›ã¦èª¿æ•´OKï¼‰
  const t = (width - CONFIG.FISH_MIN_SIZE) / Math.max(1, CONFIG.FISH_MAX_SIZE - CONFIG.FISH_MIN_SIZE);
  return Math.round(lerp(2, 4, clamp(t,0,1)));
}
function speedBySize(width){
  // å¤§ãã„ã»ã©ã‚„ã‚„é€Ÿã„ï¼ˆé€šå¸¸æ™‚ï¼‰
  const t = (width - CONFIG.FISH_MIN_SIZE) / Math.max(1, CONFIG.FISH_MAX_SIZE - CONFIG.FISH_MIN_SIZE);
  return CONFIG.BASE_SPEED * lerp(1.02, 1.18, clamp(t,0,1));
}
function dashSpeedBySize(width){
  const t = (width - CONFIG.FISH_MIN_SIZE) / Math.max(1, CONFIG.FISH_MAX_SIZE - CONFIG.FISH_MIN_SIZE);
  return CONFIG.DASH_BASE * lerp(1.0, 1.35, clamp(t,0,1));
}
function vanishChance(width){
  const t = (width - CONFIG.FISH_MIN_SIZE) / Math.max(1, CONFIG.FISH_MAX_SIZE - CONFIG.FISH_MIN_SIZE);
  return clamp(CONFIG.VANISH_BASE + CONFIG.VANISH_BY_SIZE * t, 0, 0.6);
}

/* ã‚¹ãƒãƒ¼ãƒ³ */
function spawnFish(){
  if(FISHES.length >= CONFIG.FISH_MAX_COUNT) return;

  const el = document.createElement('img');
  el.src = fishImgSrc;
  el.className = 'fish';

  const w = stage.clientWidth, h = stage.clientHeight;
  const pos = insideBox(w,h);

  const width = rand(CONFIG.FISH_MIN_SIZE, CONFIG.FISH_MAX_SIZE);
  el.style.width = width + 'px';
  el.style.left = pos.x + 'px';
  el.style.top  = pos.y + 'px';

  // é€²è¡Œæ–¹å‘ï¼šã‚„ã‚„ä¸­å¿ƒã¸
  const cx=w/2, cy=h/2;
  let angle = Math.atan2(cy - pos.y, cx - pos.x) * 180/Math.PI + rand(-35,35);
  el.style.setProperty('--rot0', `rotate(${angle + 90}deg)`); // shake/vanishç”¨ã«å›è»¢è§’ã‚’CSSå¤‰æ•°ã«æŒãŸã›ã‚‹
  el.style.transform = `rotate(${angle + 90}deg)`;

  fishLayer.appendChild(el);

  const f = {
    el, x: pos.x, y: pos.y, angle,
    width,
    speed: speedBySize(width),
    target: insideBox(w,h),
    nextRetarget: performance.now() + rand(CONFIG.RETARGET_SEC[0], CONFIG.RETARGET_SEC[1]) * 1000,
    seed: Math.random()*1000,
    alive: true,
    hp: tapsNeededBySize(width),
    lastTapAt: 0,
    dashUntil: 0,
    vanishable: false // æœ€åˆã®ã‚¿ãƒƒãƒ—ãŒå…¥ã‚‹ã¾ã§ã¯æ¶ˆãˆãªã„
  };
  FISHES.push(f);

  // ã‚¿ãƒƒãƒ—ã§HPæ¸›â†’æºã‚Œâ†’å¼·ã„ãƒ€ãƒƒã‚·ãƒ¥â†’ï¼ˆä»¥å¾Œï¼‰æ¶ˆãˆã‚‹å¯èƒ½æ€§
  el.addEventListener('pointerdown', (ev)=>{
    const now = performance.now();
    if(!f.alive) return;
    if(now - lastTapAt < CONFIG.TAP_COOLDOWN_MS) return; // å…¨ä½“é€£æ‰“æŠ‘åˆ¶
    if(now - f.lastTapAt < CONFIG.TAP_IFRAME_MS) return; // åŒä¸€é­šã®å¤šé‡ãƒ’ãƒƒãƒˆæŠ‘åˆ¶
    lastTapAt = now;
    f.lastTapAt = now;

    // æ°´ã—ã¶ã
    const rect = stage.getBoundingClientRect();
    makeSplash(ev.clientX - rect.left, ev.clientY - rect.top);

    // ãƒ€ãƒ¡ãƒ¼ã‚¸
    f.hp -= 1;

    // å°ã•ãæºã‚Œã‚‹
    el.classList.remove('shake'); // é€£ç¶šç”¨ã«ãƒªã‚»ãƒƒãƒˆ
    void el.offsetWidth;
    el.classList.add('shake');

    // ã‚¿ãƒƒãƒ—ä½ç½®ã‹ã‚‰é›¢ã‚Œã‚‹æ–¹å‘ã«å¼·ã„ãƒ€ãƒƒã‚·ãƒ¥
    const away = Math.atan2((f.y) - (ev.clientY - rect.top), (f.x) - (ev.clientX - rect.left));
    const dashSpd = dashSpeedBySize(f.width);
    f.target = {
      x: clamp(f.x + Math.cos(away)*220, CONFIG.EDGE_MARGIN, stage.clientWidth  - CONFIG.EDGE_MARGIN),
      y: clamp(f.y + Math.sin(away)*220, CONFIG.EDGE_MARGIN, stage.clientHeight - CONFIG.EDGE_MARGIN)
    };
    f.dashUntil = now + CONFIG.DASH_TIME;

    // ä»¥å¾Œã¯â€œã‚·ãƒ¥ãƒƒã¨æ¶ˆãˆã‚‹â€å¯èƒ½æ€§ãŒå‡ºã‚‹
    if(!f.vanishable) f.vanishable = true;
    if(f.vanishable && f.hp > 0){
      const p = vanishChance(f.width);
      if(Math.random() < p){
        // è‡ªç„¶ã«æ¶ˆæ»…
        f.alive = false;
        el.classList.add('vanish');
        setTimeout(()=>{
          const idx = FISHES.indexOf(f);
          if(idx !== -1) FISHES.splice(idx,1);
          el.remove();
          spawnFish();
        }, 280);
        return;
      }
    }

    // ä»•ç•™ã‚ãŸï¼ˆHPå°½ããŸï¼‰
    if(f.hp <= 0){
      f.alive = false;
      addScore(CONFIG.SCORE_PER_CATCH);
      el.classList.add('vanish'); // æ•ç²æ™‚ã‚‚â€œã‚·ãƒ¥ãƒƒâ€æ¼”å‡ºã§OK
      setTimeout(()=>{
        const idx = FISHES.indexOf(f);
        if(idx !== -1) FISHES.splice(idx,1);
        el.remove();
        spawnFish();
      }, 280);
    }
  }, {passive:true});
}

/* é€²è¡Œç®¡ç† */
function forceInwardGoal(f){
  const w = stage.clientWidth, h = stage.clientHeight;
  const cx=w/2, cy=h/2;
  const dir = Math.atan2(cy - f.y, cx - f.x);
  const dist = 120 + Math.random()*180;
  f.target = {
    x: clamp(f.x + Math.cos(dir)*dist, CONFIG.EDGE_MARGIN, w - CONFIG.EDGE_MARGIN),
    y: clamp(f.y + Math.sin(dir)*dist, CONFIG.EDGE_MARGIN, h - CONFIG.EDGE_MARGIN)
  };
  f.nextRetarget = performance.now() + rand(CONFIG.RETARGET_SEC[0], CONFIG.RETARGET_SEC[1]) * 1000;
}

function tick(now){
  const dt = (now - lastT) / 1000; lastT = now;
  const w = stage.clientWidth, h = stage.clientHeight;

  for(const f of FISHES){
    if(!f.alive) continue;

    if(now >= f.nextRetarget){
      f.target = insideBox(w,h);
      f.nextRetarget = now + rand(CONFIG.RETARGET_SEC[0], CONFIG.RETARGET_SEC[1]) * 1000;
    }

    const desired = Math.atan2(f.target.y - f.y, f.target.x - f.x) * 180/Math.PI;
    const maxTurn = CONFIG.TURN_RATE * dt;
    f.angle = stepAngle(f.angle, desired, maxTurn);

    const rad = f.angle * DEG2RAD;
    const spd = (now < f.dashUntil) ? dashSpeedBySize(f.width) : f.speed;
    const vx = Math.cos(rad) * spd * dt;
    const vy = Math.sin(rad) * spd * dt;

    let nx = f.x + vx, ny = f.y + vy;

    let bumped = false;
    const M = CONFIG.EDGE_MARGIN;
    if(nx < M){ nx = M + CONFIG.NUDGE_INWARD; bumped = true; }
    if(nx > w - M){ nx = w - M - CONFIG.NUDGE_INWARD; bumped = true; }
    if(ny < M){ ny = M + CONFIG.NUDGE_INWARD; bumped = true; }
    if(ny > h - M){ ny = h - M - CONFIG.NUDGE_INWARD; bumped = true; }

    f.x = nx; f.y = ny;
    if(bumped){
      forceInwardGoal(f);
      f.dashUntil = performance.now() + 220; // å£è¿‘ãã¯ã‚¹ãƒƒã¨å†…ã¸
    }

    if(Math.hypot(f.target.x - f.x, f.target.y - f.y) < CONFIG.GOAL_RADIUS){
      f.target = insideBox(w,h);
      f.nextRetarget = now + rand(CONFIG.RETARGET_SEC[0], CONFIG.RETARGET_SEC[1]) * 1000;
    }

    f.el.style.left = f.x + 'px';
    f.el.style.top  = f.y + 'px';
    const visualRot = f.angle + 90;
    f.el.style.setProperty('--rot0', `rotate(${visualRot}deg)`);
    f.el.style.transform = `rotate(${visualRot}deg)`;
  }

  requestAnimationFrame(tick);
}

/* åˆæœŸåŒ– */
function init(){
  const want = Math.min(CONFIG.FISH_MAX_COUNT,
    parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fish-max')) || CONFIG.FISH_MAX_COUNT);
  for(let i=0;i<want;i++) spawnFish();
  requestAnimationFrame(tick);
}
addEventListener('load', init);

addEventListener('resize', ()=>{
  for(const f of FISHES){
    f.x = clamp(f.x, CONFIG.EDGE_MARGIN, stage.clientWidth - CONFIG.EDGE_MARGIN);
    f.y = clamp(f.y, CONFIG.EDGE_MARGIN, stage.clientHeight - CONFIG.EDGE_MARGIN);
    forceInwardGoal(f);
  }
});
</script>
</body>
</html>

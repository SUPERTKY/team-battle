<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TURI – 前進主体/境界内ランダム魚</title>
<style>
  :root{
    --stage-w: min(1280px, 94vw);
    --ratio: 16/9;
    --fish-max: 6;
  }
  *{ box-sizing:border-box }
  html,body{ margin:0; height:100%; background:#05121a; }
  .wrap{ min-height:100%; display:grid; place-items:center; padding:16px; }

  .stage{
    position:relative;
    width: var(--stage-w);
    aspect-ratio: var(--ratio);
    overflow:hidden;
    border-radius:18px;
    background:#000;
    box-shadow:0 18px 48px rgba(0,0,0,.45);
  }

  .layer{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; pointer-events:none; }
  #sand{ z-index:1; }
  #waterBase{ z-index:2; opacity:.8; }
  .tint{ z-index:3; mix-blend-mode:multiply; background:rgba(25,181,193,.22); }
  .caustics{ z-index:4; opacity:.25; mix-blend-mode:screen; background:#000; filter:url(#causticsFilter); }

  /* 魚は最前面に */
  #fishLayer{ position:absolute; inset:0; z-index:10; pointer-events:none; }
  .fish{
    position:absolute;
    transform-origin:center center;
    opacity:.96;
    will-change: transform, top, left;
    image-rendering:auto;
  }
</style>
</head>
<body>
  <main class="wrap">
    <section class="stage" id="stage">
      <img id="sand" class="layer" src="assets/sand.png" alt="砂">
      <img id="waterBase" class="layer" src="assets/water_background_80percent.png" alt="水">
      <div class="layer tint"></div>
      <div class="layer caustics"></div>
      <div id="fishLayer"></div>
    </section>
  </main>

  <!-- 柔らかいカースティクス -->
  <svg width="0" height="0" style="position:absolute">
    <filter id="causticsFilter">
      <feTurbulence type="fractalNoise" baseFrequency="0.005 0.02"
        numOctaves="2" seed="5" result="noise">
        <animateTransform attributeName="patternTransform"
          type="translate" from="0 0" to="200 0"
          dur="30s" repeatCount="indefinite"/>
      </feTurbulence>
      <feColorMatrix type="matrix" values="
        1 0 0 0 0
        0 1 0 0 0
        0 0 1 0 0
        0 0 0 6 -3" result="contrast"/>
      <feGaussianBlur stdDeviation="1.2"/>
    </filter>
  </svg>

<script>
/* ====== 調整パラメータ ====== */
const CONFIG = {
  FISH_MIN_SIZE: 110,     // px（最小）
  FISH_MAX_SIZE: 220,     // px（最大）
  FISH_MAX_COUNT: 6,      // 同時数
  BASE_SPEED: 110,        // px/s（基準、サイズで補正）
  TURN_RATE: 160,         // 度/秒（最大旋回角）
  EDGE_MARGIN: 56,        // 端からの安全域
  RETARGET_SEC: [3.0, 6.5], // 目標更新間隔（秒）
  GOAL_RADIUS: 18,        // 到達とみなす半径
  NUDGE_INWARD: 14,       // 境界での押し戻し距離(px)
  WOBBLE_SPEED: 0.6,      // 見た目ローリング（Hz）
  WOBBLE_DEG: 5           // 見た目ローリング角度（度）
};

const stage = document.getElementById('stage');
const fishLayer = document.getElementById('fishLayer');
const fishImgSrc = 'assets/fish.png';

const FISHES = []; // {el,x,y,angle,speed,target:{x,y},nextRetarget,seed,width}

/* ユーティリティ */
const DEG2RAD = Math.PI/180, RAD2DEG = 180/Math.PI;
const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));
const lerp  = (a,b,t)=> a+(b-a)*t;
const rand  = (a,b)=> Math.random()*(b-a)+a;

function insideBox(w,h){ // 画面内の安全目標を返す
  return {
    x: rand(CONFIG.EDGE_MARGIN, w - CONFIG.EDGE_MARGIN),
    y: rand(CONFIG.EDGE_MARGIN, h - CONFIG.EDGE_MARGIN)
  };
}

/* 魚の生成（画面内から開始） */
function spawnFish(){
  if(FISHES.length >= CONFIG.FISH_MAX_COUNT) return;

  const el = document.createElement('img');
  el.src = fishImgSrc;
  el.className = 'fish';

  const w = stage.clientWidth, h = stage.clientHeight;

  const pos = insideBox(w,h);
  const width = rand(CONFIG.FISH_MIN_SIZE, CONFIG.FISH_MAX_SIZE);
  el.style.width = width + 'px';

  // サイズで速度スケール（大きいほどやや遅い）
  const t = (width - CONFIG.FISH_MIN_SIZE) / Math.max(1, CONFIG.FISH_MAX_SIZE - CONFIG.FISH_MIN_SIZE);
  const speed = CONFIG.BASE_SPEED * lerp(1.1, 0.75, t);

  // 初期向きは中心付近へ + ランダム
  const cx=w/2, cy=h/2;
  let angle = Math.atan2(cy - pos.y, cx - pos.x) * RAD2DEG + rand(-40,40);

  el.style.left = pos.x + 'px';
  el.style.top  = pos.y + 'px';
  el.style.transform = `rotate(${angle + 90}deg)`;
  fishLayer.appendChild(el);

  const target = insideBox(w,h);
  const now = performance.now();

  FISHES.push({
    el,
    x: pos.x, y: pos.y,
    angle, speed, width,
    target,
    nextRetarget: now + rand(CONFIG.RETARGET_SEC[0], CONFIG.RETARGET_SEC[1]) * 1000,
    seed: Math.random()*1000
  });
}

/* 角度追従（最大旋回角を守る） */
function stepAngle(cur, target, maxStep){
  let diff = ((target - cur + 540) % 360) - 180;
  diff = clamp(diff, -maxStep, maxStep);
  return cur + diff;
}

/* 目標を内側に再設定（境界で即呼ぶ） */
function forceInwardGoal(f){
  const w = stage.clientWidth, h = stage.clientHeight;
  // 現在地から中心方向へ近めの目標
  const cx=w/2, cy=h/2;
  const dir = Math.atan2(cy - f.y, cx - f.x);
  const dist = 120 + Math.random()*180;
  const nx = clamp(f.x + Math.cos(dir)*dist, CONFIG.EDGE_MARGIN, w-CONFIG.EDGE_MARGIN);
  const ny = clamp(f.y + Math.sin(dir)*dist, CONFIG.EDGE_MARGIN, h-CONFIG.EDGE_MARGIN);
  f.target = {x:nx, y:ny};
  f.nextRetarget = performance.now() + rand(CONFIG.RETARGET_SEC[0], CONFIG.RETARGET_SEC[1]) * 1000;
}

/* メインループ */
let last = performance.now();
function tick(now){
  const dt = (now - last) / 1000; last = now;
  const w = stage.clientWidth, h = stage.clientHeight;

  for(const f of FISHES){
    // 目標更新（一定間隔）
    if(now >= f.nextRetarget){
      f.target = insideBox(w,h);
      f.nextRetarget = now + rand(CONFIG.RETARGET_SEC[0], CONFIG.RETARGET_SEC[1]) * 1000;
    }

    // 目標角
    const desired = Math.atan2(f.target.y - f.y, f.target.x - f.x) * RAD2DEG;

    // 最大旋回角（dt分）
    const maxTurn = CONFIG.TURN_RATE * dt;
    f.angle = stepAngle(f.angle, desired, maxTurn);

    // 前進のみ
    const rad = f.angle * DEG2RAD;
    const vx = Math.cos(rad) * f.speed * dt;
    const vy = Math.sin(rad) * f.speed * dt;

    let nx = f.x + vx;
    let ny = f.y + vy;

    // 境界処理：はみ出し前に押し戻し＆内向き目標へ切替
    let bumped = false;
    const M = CONFIG.EDGE_MARGIN;

    if(nx < M){ nx = M + CONFIG.NUDGE_INWARD; bumped = true; }
    if(nx > w - M){ nx = w - M - CONFIG.NUDGE_INWARD; bumped = true; }
    if(ny < M){ ny = M + CONFIG.NUDGE_INWARD; bumped = true; }
    if(ny > h - M){ ny = h - M - CONFIG.NUDGE_INWARD; bumped = true; }

    f.x = nx; f.y = ny;

    if(bumped){
      // 即座に内側目標へ変更し、向きも内側へ素早く向ける
      forceInwardGoal(f);
      const inward = Math.atan2(h/2 - f.y, w/2 - f.x) * RAD2DEG;
      f.angle = stepAngle(f.angle, inward, CONFIG.TURN_RATE); // 1フレーム強制気味に内側へ
    }

    // 目標に到達したら次の目標
    const dx = f.target.x - f.x, dy = f.target.y - f.y;
    if(Math.hypot(dx,dy) < CONFIG.GOAL_RADIUS){
      f.target = insideBox(w,h);
      f.nextRetarget = now + rand(CONFIG.RETARGET_SEC[0], CONFIG.RETARGET_SEC[1]) * 1000;
    }

    // 見た目の回転（画像上が頭なので +90°）。軽いローリングのみ付与
    const roll = Math.sin((now/1000 + f.seed)*2*Math.PI*CONFIG.WOBBLE_SPEED) * CONFIG.WOBBLE_DEG;
    f.el.style.left = f.x + 'px';
    f.el.style.top  = f.y + 'px';
    f.el.style.transform = `rotate(${f.angle + 90 + roll}deg)`;
  }
  requestAnimationFrame(tick);
}

/* 初期化 */
function init(){
  const want = Math.min(CONFIG.FISH_MAX_COUNT,
    parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fish-max')) || CONFIG.FISH_MAX_COUNT);
  for(let i=0;i<want;i++) spawnFish();
  requestAnimationFrame(tick);
}
addEventListener('load', init);
addEventListener('resize', ()=> {
  // 画面サイズ変化時も全員が安全域にいるように少しだけ内側へ
  for(const f of FISHES){
    f.x = clamp(f.x, CONFIG.EDGE_MARGIN, stage.clientWidth - CONFIG.EDGE_MARGIN);
    f.y = clamp(f.y, CONFIG.EDGE_MARGIN, stage.clientHeight - CONFIG.EDGE_MARGIN);
    forceInwardGoal(f);
  }
});
</script>
</body>
</html>

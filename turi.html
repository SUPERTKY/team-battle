<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TURI – 超ムズ完全版（選択禁止）</title>
<style>
  html,body{
    margin:0; height:100%; background:#05121a; overflow:hidden;
    user-select: none;           /* ★テキスト選択禁止 */
    -webkit-user-select: none;   /* Safari対応 */
    -ms-user-select: none;       /* 古いIE対応 */
  }
  .stage{
    position:relative;
    width:100vw; height:100vh;
    overflow:hidden;
    background:#000;
    user-select: none;           /* ★ドラッグ範囲選択禁止 */
  }

  /* 背景 */
  .layer{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    pointer-events:none;
    user-select:none;            /* ★画像も選択禁止 */
    -webkit-user-drag: none;     /* ★画像ドラッグ禁止 */
  }
  #sand{ z-index:1; }
  #waterBase{ z-index:2; opacity:.8; }
  .tint{ z-index:3; mix-blend-mode:multiply; background:rgba(25,181,193,.22); }
  .caustics{ z-index:4; opacity:.25; mix-blend-mode:screen; background:#000; filter:url(#causticsFilter); }

  /* 魚 */
  #fishLayer{ position:absolute; inset:0; z-index:10; pointer-events:none; }
  .fish{
    position:absolute;
    transform-origin:center center;
    pointer-events:auto;
    user-select:none;
    -webkit-user-drag: none; /* ★魚ドラッグ禁止 */
    will-change:left, top, transform;
  }

  .shake{ animation: shake .22s ease-out; }
  @keyframes shake{
    0%{   transform: var(--rot0) translate(0,0) }
    35%{  transform: var(--rot0) translate(3px,-2px) }
    70%{  transform: var(--rot0) translate(-2px,2px) }
    100%{ transform: var(--rot0) translate(0,0) }
  }

  .vanish{ animation: vanish .25s ease forwards; }
  @keyframes vanish{
    to{ opacity:0; transform: var(--rot0) scale(.65); filter:blur(2px); }
  }

  .splash{
    position:absolute; width:10px; height:10px; border-radius:50%;
    left:0; top:0; transform: translate(-50%,-50%);
    background: rgba(255,255,255,.9);
    mix-blend-mode:screen;
    filter: blur(.5px);
    pointer-events:none; z-index:11;
    animation: ripple .5s ease-out forwards;
  }
  @keyframes ripple{ to{ width:140px; height:140px; opacity:0; } }
  /* === Inventory UI === */
.hud{
  position:fixed; right:12px; top:12px; z-index:20; display:flex; gap:8px;
}
.btn{
  background:#0b1c26aa; border:1px solid #7ee0ff66; color:#dff7ff;
  padding:8px 12px; border-radius:10px; backdrop-filter: blur(4px);
  font-weight:600; cursor:pointer
}
.btn:hover{ background:#0f2a36cc; }
.inv{
  position:fixed; right:12px; top:56px; width:min(420px, calc(100vw - 24px));
  max-height:min(70vh, 520px); overflow:auto; z-index:20;
  background:#06131bdf; border:1px solid #7ee0ff33; border-radius:12px;
  backdrop-filter: blur(6px); color:#e8fbff; padding:10px 10px 12px;
}
.inv h3{ margin:6px 8px 8px; font-size:16px }
.inv .meta{ margin:0 8px 8px; font-size:12px; opacity:.8 }
.inv .list{ display:grid; grid-template-columns: 1fr auto; gap:6px 10px; padding:6px 8px }
.inv .pill{ padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #ffffff22 }
.inv .rank-COMMON{ background:#0f1b21; }
.inv .rank-UNCOMMON{ background:#10241d; }
.inv .rank-RARE{ background:#0f1e2c; }
.inv .rank-EPIC{ background:#1b0f26; }
.inv .rank-LEGENDARY{ background:#291f0a; }
.inv .row{ display:contents }
.inv .name{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
.hidden{ display:none !important; }

/* Toast */
.toast{
  position:fixed; left:50%; transform:translateX(-50%);
  bottom:18px; z-index:30; background:#0b1c26f0; color:#e8fbff;
  border:1px solid #7ee0ff55; border-radius:10px; padding:10px 14px;
  backdrop-filter: blur(6px); font-size:14px; pointer-events:none; opacity:0;
  transition: opacity .2s ease, transform .2s ease;
}
.toast.show{ opacity:1; transform:translateX(-50%) translateY(-6px); }

</style>
</head>
<body>
  <section class="stage" id="stage">
    <img id="sand" class="layer" src="assets/sand.png" alt="砂" draggable="false">
    <img id="waterBase" class="layer" src="assets/water_background_80percent.png" alt="水" draggable="false">
    <div class="layer tint"></div>
    <div class="layer caustics"></div>
    <div id="fishLayer"></div>
  </section>
  <!-- HUD: ボタン -->


<!-- Inventory パネル -->
<div id="invPanel" class="inv hidden">
  <h3>インベントリ</h3>
  <div class="meta" id="invMeta">合計 0 匹</div>
  <div class="list" id="invList"></div>
</div>

<!-- Toast -->
<div id="toast" class="toast" aria-live="polite"></div>


  <svg width="0" height="0" style="position:absolute">
    <filter id="causticsFilter">
      <feTurbulence type="fractalNoise" baseFrequency="0.005 0.02"
        numOctaves="2" seed="5" result="noise">
        <animateTransform attributeName="patternTransform"
          type="translate" from="0 0" to="200 0"
          dur="30s" repeatCount="indefinite"/>
      </feTurbulence>
      <feColorMatrix type="matrix" values="
        1 0 0 0 0
        0 1 0 0 0
        0 0 1 0 0
        0 0 0 6 -3" result="contrast"/>
      <feGaussianBlur stdDeviation="1.2"/>
    </filter>
  </svg>

<script>
const CONFIG = {
  FISH_MIN_SIZE: 100,
  FISH_MAX_SIZE: 220,
  FISH_MAX_COUNT: 4, 

  BASE_SPEED: 300,       // ★ 初速を2倍（280→560）
  SPEED_BOOST: 2,      // ★ 加速倍率もUP（1.45→1.5）
  SPEED_MAX: 3,        // ★ 最大8倍速まで許可
  TURN_RATE: 240,
  RETARGET_SEC: [0.8, 1.6], // ★進路変更もさらに頻繁に
  EDGE_MARGIN: 48,
  GOAL_RADIUS: 14,

  HP_MIN: 3,
  HP_MAX: 6,
  VANISH_TIME_RANGE: [1000, 5000], // ★消滅までの猶予も短縮（0.45〜1.0秒）

  DASH_DIST: 240,
  DASH_TIME: 240
};
  const INV_LIMIT = 10;

  // ===== Catch Roll (sizeが大きいほど上位が出やすい) =====
const CATCH = {
  ranks: ["COMMON","UNCOMMON","RARE","EPIC","LEGENDARY"],
  // 各ランクで出るデフォルトの魚名（適当でOK／後で差し替え可）
  speciesByRank: {
    COMMON:    ["ワカサギ","キンギョ","カダヤシ"],
    UNCOMMON:  ["ブルーギル","フナ","オイカワ"],
    RARE:      ["ニジマス","ブラックバス","コイ"],
    EPIC:      ["イトウ","アカメ","サクラマス"],
    LEGENDARY: ["シーラカンス","ドラゴンフィッシュ","メガサーモン"]
  }
};

// size→[0,1]に正規化
function normSize(px){
  return clamp((px - CONFIG.FISH_MIN_SIZE) / (CONFIG.FISH_MAX_SIZE - CONFIG.FISH_MIN_SIZE), 0, 1);
}

// ランクをロール（ベース確率＋サイズ補正）
// ベース: C 60%, U 25%, R 10%, E 4%, L 1%
// 補正: 大きいほど上位に +t*係数 で寄せる（合計1に再正規化）
function rollRank(sizePx){
  const t = normSize(sizePx); // 0(小)〜1(大)
  let pCommon    = 0.60 - 0.30*t;           // 小さいとC寄り
  let pUncommon  = 0.25 - 0.05*t;
  let pRare      = 0.10 + 0.15*t;
  let pEpic      = 0.04 + 0.12*t;
  let pLegendary = 0.01 + 0.08*t;           // 大きいと伝説寄り

  // マイナス回避＆正規化
  pCommon    = Math.max(0, pCommon);
  pUncommon  = Math.max(0, pUncommon);
  pRare      = Math.max(0, pRare);
  pEpic      = Math.max(0, pEpic);
  pLegendary = Math.max(0, pLegendary);
  const S = pCommon+pUncommon+pRare+pEpic+pLegendary || 1;
  pCommon/=S; pUncommon/=S; pRare/=S; pEpic/=S; pLegendary/=S;

  const r=Math.random();
  if(r < pLegendary) return "LEGENDARY";
  if(r < pLegendary+pEpic) return "EPIC";
  if(r < pLegendary+pEpic+pRare) return "RARE";
  if(r < pLegendary+pEpic+pRare+pUncommon) return "UNCOMMON";
  return "COMMON";
}
// 角度補間（短い回転）
function lerpAngle(a, b, t){
  const diff = ((b - a + 540) % 360) - 180;
  return a + diff * t;
}

// 端への接近度（予測回避で使用：既に入れてなければ追加）
function edgeProximity(x, y, w, h, margin = CONFIG.EDGE_MARGIN) {
  const dx = Math.min(x - margin, (w - margin) - x);
  const dy = Math.min(y - margin, (h - margin) - y);
  const nx = clamp(1 - (dx / margin), 0, 1);
  const ny = clamp(1 - (dy / margin), 0, 1);
  return Math.max(nx, ny);
}

function pickSpecies(rank){
  const arr = CATCH.speciesByRank[rank] || ["???"];
  return arr[(Math.random()*arr.length)|0];
}

// 捕獲時のデバッグ出力
function debugCatchLog({rank,species,sizePx,hpLeft}){
  console.log(
    `[CATCH] rank=${rank} species=${species} size=${Math.round(sizePx)}px hpLeft=${hpLeft}`
  );
}
// 端への接近度（0〜1）。1に近いほど端ギリギリ
function edgeProximity(x, y, w, h, margin = CONFIG.EDGE_MARGIN) {
  const dx = Math.min(x - margin, (w - margin) - x);
  const dy = Math.min(y - margin, (h - margin) - y);
  const nx = clamp(1 - (dx / margin), 0, 1);
  const ny = clamp(1 - (dy / margin), 0, 1);
  return Math.max(nx, ny);
}

// 角度補間（短い回転方向で補間）
function lerpAngle(a, b, t){
  const diff = ((b - a + 540) % 360) - 180;
  return a + diff * t;
}


const stage = document.getElementById('stage');
const fishLayer = document.getElementById('fishLayer');
const fishImgSrc = 'assets/fish.png';
const FISHES = [];
// spawnFish 内の f を作る直前あたり


const DEG2RAD = Math.PI/180;
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(a,b)=>Math.random()*(b-a)+a;

function insideBox(w,h){
  return {x:rand(CONFIG.EDGE_MARGIN,w-CONFIG.EDGE_MARGIN),
          y:rand(CONFIG.EDGE_MARGIN,h-CONFIG.EDGE_MARGIN)};
}
function stepAngle(cur,target,maxStep){
  let diff=((target-cur+540)%360)-180;
  return cur+clamp(diff,-maxStep,maxStep);
}
function makeSplash(x,y){
  const sp=document.createElement('div');
  sp.className='splash';
  sp.style.left=x+'px';
  sp.style.top=y+'px';
  stage.appendChild(sp);
  sp.addEventListener('animationend',()=>sp.remove());
}

function spawnFish(){
  if(FISHES.length>=CONFIG.FISH_MAX_COUNT) return;

  const el=document.createElement('img');
  el.src=fishImgSrc;
  el.className='fish';
  el.draggable=false;

  const w=stage.clientWidth, h=stage.clientHeight;
  const pos=insideBox(w,h);

  // ここで size を作る（この関数のローカル変数）
  const size = rand(CONFIG.FISH_MIN_SIZE, CONFIG.FISH_MAX_SIZE);

  // ★サイズ→速度：最小サイズ=BASE_SPEED、最大サイズ=BASE_SPEED*2
  const t = (size - CONFIG.FISH_MIN_SIZE) / (CONFIG.FISH_MAX_SIZE - CONFIG.FISH_MIN_SIZE);
  const initSpeed = CONFIG.BASE_SPEED * (1 + clamp(t,0,1)); // 1～2倍

  el.style.width = size + 'px';
  el.style.left  = pos.x + 'px';
  el.style.top   = pos.y + 'px';
  fishLayer.appendChild(el);

  const hp = Math.round(lerp(
    CONFIG.HP_MIN, CONFIG.HP_MAX,
    (size - CONFIG.FISH_MIN_SIZE) / (CONFIG.FISH_MAX_SIZE - CONFIG.FISH_MIN_SIZE)
  ));

  const cx=w/2, cy=h/2;
  let angle = Math.atan2(cy-pos.y, cx-pos.x)*180/Math.PI + rand(-35,35);
  el.style.setProperty('--rot0',`rotate(${angle+90}deg)`);
  el.style.transform = `rotate(${angle+90}deg)`;

const f = {
  el,x:pos.x,y:pos.y,angle,width:size,
  speed: initSpeed,
  target: insideBox(w,h),
  nextRetarget: performance.now()+rand(...CONFIG.RETARGET_SEC)*1000,
  hp,alive:true,vanishAt:null,dashUntil:0,

  // ★ 追加：曲率ノイズ（常時うねり）
  curvePhase: rand(0, Math.PI*2),
  curveSpeed: rand(0.8, 1.6),     // うねりの速さ
  curveMag:   rand(6, 22),        // 角度うねりの振幅[deg]

  // ★ 追加：一時的な円運動（旋回）
  orbitUntil: 0,
  orbitCenter: null,
  orbitRadius: 0,
  orbitDir: (Math.random()<0.5? -1: 1),
  orbitAng: 0
};

  FISHES.push(f);

  el.addEventListener('pointerdown',(ev)=>{
    if(!f.alive) return;
    f.hp--;
    const rect=stage.getBoundingClientRect();
    makeSplash(ev.clientX-rect.left, ev.clientY-rect.top);

    el.classList.remove('shake');
    requestAnimationFrame(()=> el.classList.add('shake'));

    f.speed = Math.min(f.speed * CONFIG.SPEED_BOOST,
                       CONFIG.BASE_SPEED * CONFIG.SPEED_MAX);

    if(!f.vanishAt){
      f.vanishAt = performance.now() + rand(...CONFIG.VANISH_TIME_RANGE);
    }

    const px=ev.clientX-rect.left, py=ev.clientY-rect.top;
    const away=Math.atan2(f.y-py,f.x-px);
    f.target = {
      x:clamp(f.x+Math.cos(away)*CONFIG.DASH_DIST,CONFIG.EDGE_MARGIN,w-CONFIG.EDGE_MARGIN),
      y:clamp(f.y+Math.sin(away)*CONFIG.DASH_DIST,CONFIG.EDGE_MARGIN,h-CONFIG.EDGE_MARGIN)
    };
    f.dashUntil = performance.now()+CONFIG.DASH_TIME;

    if(f.hp<=0){
      f.alive=false;
      vanishFish(f,true);
    }
  },{passive:true});
  function startOrbit(f, w, h, now){
  // 画面内で安全に回れる中心と半径を決定
  const r = rand(80, 220);
  const cx = clamp(f.x, CONFIG.EDGE_MARGIN + r, w - CONFIG.EDGE_MARGIN - r);
  const cy = clamp(f.y, CONFIG.EDGE_MARGIN + r, h - CONFIG.EDGE_MARGIN - r);

  f.orbitCenter = {x: cx, y: cy};
  f.orbitRadius = r;
  f.orbitAng    = Math.atan2(f.y - cy, f.x - cx) * 180/Math.PI;
  f.orbitDir    = (Math.random()<0.5? -1: 1);
  f.orbitUntil  = now + rand(900, 1800); // 0.9〜1.8秒だけ旋回
}

}

function vanishFish(f,caught=false){
  // ★ caught時にデバッグ出力
  if (caught) {
    const rank = rollRank(f.width);
    const species = pickSpecies(rank);
    debugCatchLog({rank, species, sizePx: f.width, hpLeft: f.hp});

    // ▼ 追記：インベントリ登録
    addCatchToInv({ rank, species, sizePx: f.width });
  }

  f.el.classList.add('vanish');
  setTimeout(()=>{
    const idx=FISHES.indexOf(f);
    if(idx!==-1)FISHES.splice(idx,1);
    f.el.remove();
    spawnFish();
  },250);
}

let last=performance.now();
function tick(now){
  const dt=(now-last)/1000; last=now;
  const w=stage.clientWidth,h=stage.clientHeight;
  for(const f of FISHES){
    if(!f.alive) continue;
    if(f.vanishAt && now>=f.vanishAt){
      f.alive=false; vanishFish(f,false); continue;
    }
    if(now>=f.nextRetarget){
      f.target=insideBox(w,h);
      f.nextRetarget=now+rand(...CONFIG.RETARGET_SEC)*1000;
    }
    const desired = Math.atan2(f.target.y - f.y, f.target.x - f.x) * 180/Math.PI;

// 端に近いほど desired を画面中心方向へ少しだけ寄せる（速度は触らない）
const prox = edgeProximity(f.x, f.y, w, h, CONFIG.EDGE_MARGIN); // 0〜1
if (prox > 0) {
  const centerAngle = Math.atan2((h*0.5) - f.y, (w*0.5) - f.x) * 180/Math.PI;
  const blended = lerpAngle(desired, centerAngle, Math.min(0.8, prox)); // 最大80%だけ中心寄り
  f.angle = stepAngle(f.angle, blended, CONFIG.TURN_RATE * dt);
} else {
  f.angle = stepAngle(f.angle, desired, CONFIG.TURN_RATE * dt);
}

    const rad=f.angle*DEG2RAD;
    f.x+=Math.cos(rad)*f.speed*dt;
    f.y+=Math.sin(rad)*f.speed*dt;
    f.x=clamp(f.x,CONFIG.EDGE_MARGIN,w-CONFIG.EDGE_MARGIN);
    f.y=clamp(f.y,CONFIG.EDGE_MARGIN,h-CONFIG.EDGE_MARGIN);
    const visualRot=f.angle+90;
    f.el.style.setProperty('--rot0',`rotate(${visualRot}deg)`);
    f.el.style.left=f.x+'px';
    f.el.style.top=f.y+'px';
    f.el.style.transform=`rotate(${visualRot}deg)`;
  }
  requestAnimationFrame(tick);
}

function init(){
  for(let i=0;i<CONFIG.FISH_MAX_COUNT;i++) spawnFish();
  requestAnimationFrame(tick);
}
  // === Inventory 初期化/UIイベント ===
addEventListener('load', () => {
  renderInventory();

  const btn = document.getElementById('invBtn');
  const clr = document.getElementById('invClearBtn');
  btn && btn.addEventListener('click', toggleInventory);
  clr && clr.addEventListener('click', clearInventory);

  // キー操作: Iで開閉 / Cで全消去
  addEventListener('keydown', (e)=>{
    if(e.key==='i' || e.key==='I'){ toggleInventory(); }
    if(e.key==='c' || e.key==='C'){ clearInventory(); }
  });
});

addEventListener('load',init);
  // === Inventory ===
const INV_KEY = 'turi_inventory_v1';
const RANKS = CATCH.ranks; // ["COMMON","UNCOMMON",...]
let inventory = loadInv();

function loadInv(){
  try{
    const j = localStorage.getItem(INV_KEY);
    return j ? JSON.parse(j) : { total:0, bySpecies:{} };
  }catch(_){ return { total:0, bySpecies:{} }; }
}

function saveInv(){ localStorage.setItem(INV_KEY, JSON.stringify(inventory)); }

function addCatchToInv({rank, species, sizePx}){
  if (inventory.total >= INV_LIMIT){
    showToast("インベントリがいっぱいです");
    return; // 追加しない
  }

  inventory.total++;
  inventory.bySpecies[species] = (inventory.bySpecies[species]||0)+1;
  saveInv();
  renderInventory();
  showToast(`+1 ${species} を釣った！（合計 ${inventory.bySpecies[species]}）`);
}



function clearInventory(){
  if(!confirm('インベントリを全て消去しますか？')) return;
  inventory = { total:0, bySpecies:{}, byRank:{} };
  saveInv();
  renderInventory();
  showToast('インベントリを消去しました');
}

function renderInventory(){
  const meta = document.getElementById('invMeta');
  const list = document.getElementById('invList');
  if(!meta || !list) return;

  meta.textContent = `合計 ${inventory.total} 匹`;

  // 名前順でソート
  const entries = Object.entries(inventory.bySpecies)
    .sort((a,b)=>a[0].localeCompare(b[0],'ja'));

  list.innerHTML = '';
  for(const [name,count] of entries){
    const rowName = document.createElement('div');
    rowName.className = 'row name';
    rowName.textContent = name;

    const rowCount = document.createElement('div');
    rowCount.className = 'row';
    rowCount.innerHTML = `<span class="pill">${count}</span>`;

    list.appendChild(rowName);
    list.appendChild(rowCount);
  }
}


function toggleInventory(){
  const p = document.getElementById('invPanel');
  if(p) p.classList.toggle('hidden');
}
function showToast(html){
  const t = document.getElementById('toast');
  if(!t) return;
  t.innerHTML = html;
  t.classList.add('show');
  clearTimeout(showToast._timer);
  showToast._timer = setTimeout(()=> t.classList.remove('show'), 1600);
}

</script>
</body>
</html>















